# -*- coding: utf-8 -*-
"""Q5

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1NiQ_tcgFqs1Iw7DwmN7juAiHvsb-bhAI
"""

import matplotlib.pyplot as plt
from PIL import Image
import colorsys
from google.colab import files

from google.colab import files
uploaded = files.upload()

from PIL import Image
import numpy as np

image_path = 'Test Image.png'
image = Image.open(image_path).convert('L')
image = np.array(image)

# Load and normalize the input image
for image_path in uploaded.keys():
    input_image = Image.open(image_path).convert('L')
    image_array = np.array(input_image) / 255.0

# Custom Sobel kernels for gradient calculation in x and y directions
gradient_x = np.array([[-1, 0, 1],
                       [-2, 0, 2],
                       [-1, 0, 1]])

gradient_y = np.array([[-1, -2, -1],
                       [0,  0,  0],
                       [1,  2,  1]])

# Function to apply convolution with zero-padding
def perform_convolution(image, kernel):
    img_height, img_width = image.shape
    kernel_height, kernel_width = kernel.shape

    # Pad the image
    pad_height = kernel_height // 2
    pad_width = kernel_width // 2

    padded_img = np.pad(image, ((pad_height, pad_height), (pad_width, pad_width)), mode='constant')

    # Initialize the output image
    convolved_img = np.zeros_like(image)

    # Perform convolution operation
    for i in range(img_height):
        for j in range(img_width):
            region = padded_img[i:i + kernel_height, j:j + kernel_width]
            convolved_img[i, j] = np.sum(region * kernel)

    return convolved_img

# Custom Sobel filter function to calculate gradients and direction
def apply_custom_sobel(image):

    # Compute gradients using custom Sobel filters
    gradient_x_result = perform_convolution(image, gradient_x)
    gradient_y_result = perform_convolution(image, gradient_y)

    # Compute gradient magnitude and orientation
    magnitude = np.sqrt(gradient_x_result**2 + gradient_y_result**2)
    orientation = np.arctan2(gradient_y_result, gradient_x_result)

    # Normalize magnitude to [0, 1]
    magnitude = (magnitude - np.min(magnitude)) / (np.max(magnitude) - np.min(magnitude))

    return magnitude, orientation

# Convert magnitude and orientation to HSV color space for better visualization
def sobel_to_color(magnitude, orientation):

    hsv_img = np.zeros((magnitude.shape[0], magnitude.shape[1], 3), dtype=np.float32)

    # Normalize orientation from radians to hue (between 0 and 1)
    hue = (orientation + np.pi) / (2 * np.pi)

    # Set magnitude as saturation and value in HSV space
    saturation = magnitude
    value = magnitude

    # Combine hue, saturation, and value into an HSV image
    for i in range(magnitude.shape[0]):
        for j in range(magnitude.shape[1]):
            hsv_img[i, j] = [hue[i, j], saturation[i, j], value[i, j]]

    # Convert HSV to RGB
    rgb_img = np.zeros_like(hsv_img)
    for i in range(hsv_img.shape[0]):
        for j in range(hsv_img.shape[1]):
            h, s, v = hsv_img[i, j]
            rgb_img[i, j] = colorsys.hsv_to_rgb(h, s, v)

    return rgb_img

# Step 1: Apply custom Sobel filter to compute magnitude and orientation
magnitude, orientation = apply_custom_sobel(image_array)

# Step 2: Convert Sobel filter results to HSV and then to RGB for visualization
sobel_rgb_visualization = sobel_to_color(magnitude, orientation)
# Step 3: Display the results
plt.figure(figsize=(12, 6))
# Original grayscale image
plt.subplot(1, 3, 1)
plt.imshow(image_array, cmap='gray')
plt.title('Original Image')

# Gradient magnitude
plt.subplot(1, 3, 2)
plt.imshow(magnitude, cmap='gray')
plt.title('Gradient Magnitude')
# Sobel filter visualization (HSV color space)
plt.subplot(1, 3, 3)
plt.imshow(sobel_rgb_visualization)
plt.title('Sobel Visualization (HSV)')
plt.tight_layout()
plt.show()